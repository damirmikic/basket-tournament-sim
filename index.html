<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comprehensive Tournament Odds Simulator</title>
    <style>
        :root {
            --primary-bg: #1f2937; --secondary-bg: #374151; --text-color: #f3f4f6;
            --accent-color: #22c55e; --accent-hover: #16a34a; --border-color: #4b5563;
            --header-font: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --body-font: 'Inter', 'Arial', sans-serif;
        }
        body { font-family: var(--body-font); background-color: var(--primary-bg); color: var(--text-color); margin: 0; padding: 20px; display: flex; justify-content: center; }
        .container { width: 100%; max-width: 1100px; background-color: var(--secondary-bg); padding: 25px; border-radius: 12px; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3); }
        h1, h2, h3, h4 { font-family: var(--header-font); color: var(--accent-color); border-bottom: 2px solid var(--border-color); padding-bottom: 10px; text-align: center; }
        h3 { color: var(--text-color); border-bottom: 1px solid var(--border-color); margin-top: 35px; font-size: 1.3em; }
        h4 { font-size: 1.1em; margin-top: 30px; border-bottom-width: 1px; color: var(--text-color); }
        .grid-layout { display: grid; gap: 20px; }
        .grid-cols-2 { grid-template-columns: 1fr 1fr; }
        .grid-cols-3 { grid-template-columns: 1fr 1fr 1fr; }
        .control-group { background-color: var(--primary-bg); padding: 20px; border-radius: 8px; border: 1px solid var(--border-color); }
        label { display: block; margin-bottom: 8px; font-weight: 600; font-size: 0.9em; }
        textarea, select, input[type="number"] { width: 100%; padding: 10px; background-color: var(--secondary-bg); border: 1px solid var(--border-color); color: var(--text-color); border-radius: 5px; box-sizing: border-box; font-size: 1em; resize: vertical; }
        button, .button { background-color: var(--accent-color); color: white; padding: 12px 20px; border: none; border-radius: 5px; cursor: pointer; font-size: 1.1em; font-weight: bold; font-family: var(--header-font); width: 100%; transition: background-color 0.3s ease; text-align: center; display: inline-block; box-sizing: border-box; }
        button:hover:not(:disabled), .button:hover { background-color: var(--accent-hover); }
        button:disabled { background-color: #555; cursor: not-allowed; }
        #status { text-align: center; margin-top: 15px; font-style: italic; height: 30px; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; font-size: 0.9em; }
        th, td { padding: 12px 8px; border: 1px solid var(--border-color); text-align: center; }
        th { background-color: var(--primary-bg); color: var(--accent-color); font-weight: 600; }
        td:first-child { text-align: left; font-weight: bold; padding-left: 12px; }
        .settings-bar { display: flex; justify-content: space-between; align-items: center; gap: 20px; margin-top: 20px; padding: 15px; background-color: var(--primary-bg); border-radius: 8px; }
        .switch { position: relative; display: inline-block; width: 60px; height: 34px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #6b7280; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 26px; width: 26px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--accent-color); }
        input:checked + .slider:before { transform: translateX(26px); }
        .toggle-label { display: flex; align-items: center; gap: 10px; font-weight: 600; }
        #margin-info { font-size: 0.8em; color: #a5b4fc; visibility: hidden; }
        .tab-container { margin-top:25px; }
        .tab-buttons { border-bottom: 2px solid var(--border-color); }
        .tab-button { background-color: transparent; border: none; padding: 10px 20px; cursor: pointer; color: var(--text-color); font-size: 1.1em; font-family: var(--header-font); border-radius: 8px 8px 0 0; }
        .tab-button.active { background-color: var(--secondary-bg); border: 2px solid var(--border-color); border-bottom: 2px solid var(--secondary-bg); }
        .tab-content { display: none; padding: 20px 0; }
        .tab-content.active { display: block; }
        .collapsible { background-color: var(--primary-bg); color: var(--accent-color); cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 1.2em; font-family: var(--header-font); border-radius: 8px; margin-bottom: 15px; }
        .collapsible:after { content: '\\002B'; color: white; font-weight: bold; float: right; margin-left: 5px; }
        .collapsible.active:after { content: "\\2212"; }
        .collapsible-content { padding: 0 18px; max-height: 0; overflow: hidden; transition: max-height 0.2s ease-out; background-color: var(--primary-bg); border-radius: 0 0 8px 8px; margin-bottom: 15px;}
        .progress-bar-container { width: 100%; background-color: var(--primary-bg); border-radius: 5px; margin-top: 5px; display: none; }
        .progress-bar { height: 10px; width: 0%; background-color: var(--accent-color); border-radius: 5px; transition: width 0.2s ease; }
        @media (max-width: 768px) { .grid-cols-2, .grid-cols-3 { grid-template-columns: 1fr; } .settings-bar { flex-direction: column; } }
    </style>
</head>
<body>
    <div class="container">
        <h1>Comprehensive Tournament Odds Simulator</h1>
        
        <button type="button" class="collapsible">Optional: Calculate Ratings From Outright Odds</button>
        <div class="collapsible-content">
            <div class="control-group" style="border:none; padding-top:0;">
                <label for="outrightOddsData">Paste Outright Odds (Format: team,group,odds)</label>
                <textarea id="outrightOddsData" rows="6" placeholder="e.g.&#10;Serbia,A,2.8&#10;Germany,B,5.0&#10;France,D,6.0"></textarea>
                <button type="button" id="calculateRatingsBtn" style="margin-top:15px;">Calculate and Populate Ratings</button>
            </div>
        </div>

        <div class="grid-layout grid-cols-3">
            <div class="control-group">
                <label for="teamData">Team Data (team,group,rating)</label>
                <textarea id="teamData" rows="8"></textarea>
            </div>
            <div class="control-group">
                 <label for="numSimulations">Simulations</label>
                 <input type="number" id="numSimulations" value="10000" min="100" step="100">
                 <label for="hostTeam" style="margin-top: 15px;">Host Team</label>
                 <select id="hostTeam"><option value="none">None</option></select>
                 <label for="groupFormat" style="margin-top: 15px;">Group Format</label>
                 <div><input type="radio" id="srr" name="groupFormat" value="srr" checked><label for="srr" style="display: inline;font-weight:normal;">SRR</label><input type="radio" id="drr" name="groupFormat" value="drr" style="margin-left:15px;"><label for="drr" style="display: inline;font-weight:normal;">DRR</label></div>
            </div>
             <div class="control-group">
                <label>Betting Margin (%)</label>
                <div class="grid-layout grid-cols-2">
                     <div>
                        <label for="groupMargin" style="font-size:0.8em; font-weight:normal;">Group</label>
                        <input type="number" id="groupMargin" value="8" min="0">
                     </div>
                     <div>
                        <label for="tourneyMargin" style="font-size:0.8em; font-weight:normal;">Tournament</label>
                        <input type="number" id="tourneyMargin" value="10" min="0">
                     </div>
                </div>
                <label for="ratingScalingFactor" style="margin-top: 15px;">Rating Scaling Factor</label>
                <input type="number" id="ratingScalingFactor" value="30" step="1">
                <small style="font-size: 0.8em; opacity: 0.7;">Higher value = more upsets.</small>
            </div>
        </div>
        <div class="control-group" style="margin-top:20px;">
             <label for="knockoutStructure">Knockout Bracket Structure</label>
             <textarea id="knockoutStructure" rows="4"></textarea>
        </div>

        <div class="settings-bar">
            <div class="toggle-label">
                <span>Probabilities</span>
                <label class="switch"><input type="checkbox" id="displayModeToggle"><span class="slider"></span></label>
                <span>Odds <span id="margin-info"></span></span>
            </div>
            <button id="runButton">▶️ Run Simulation</button>
        </div>
        
        <div id="status">Ready.</div>
        <div class="progress-bar-container">
            <div class="progress-bar"></div>
        </div>

        <button type="button" class="collapsible">Head-to-Head Progression</button>
        <div class="collapsible-content">
            <div class="control-group" style="border:none; padding-top:0;">
                <div class="grid-layout grid-cols-3">
                    <div>
                        <label for="h2h-team-a">Team A</label>
                        <select id="h2h-team-a"></select>
                    </div>
                    <div>
                        <label for="h2h-team-b">Team B</label>
                        <select id="h2h-team-b"></select>
                    </div>
                    <div style="align-self: end;">
                        <button type="button" id="calculateH2HBtn">Calculate</button>
                    </div>
                </div>
                <div id="h2h-results" style="margin-top: 20px; text-align: center; font-size: 1.1em;"></div>
            </div>
        </div>

        <div class="tab-container">
            <div class="tab-buttons">
                <button class="tab-button active" onclick="openTab('overall-markets')">Overall Markets</button>
                <button class="tab-button" onclick="openTab('team-view')">Team-Specific View</button>
            </div>
            <div id="overall-markets" class="tab-content active"></div>
            <div id="team-view" class="tab-content">
                <label for="team-select">Select a Team to Analyze</label>
                <select id="team-select"></select>
                <div id="team-specific-results"></div>
            </div>
        </div>
    </div>

    <script>
        const HOME_ADVANTAGE_RATING_BONUS = 5;

        // --- DOM Elements & Event Listeners ---
        const teamDataEl = document.getElementById('teamData'), hostTeamEl = document.getElementById('hostTeam'),
              numSimulationsEl = document.getElementById('numSimulations'), knockoutStructureEl = document.getElementById('knockoutStructure'),
              runButtonEl = document.getElementById('runButton'), statusEl = document.getElementById('status'),
              displayModeToggle = document.getElementById('displayModeToggle'), groupMarginEl = document.getElementById('groupMargin'),
              tourneyMarginEl = document.getElementById('tourneyMargin'), marginInfoEl = document.getElementById('margin-info'),
              teamSelectEl = document.getElementById('team-select'), overallMarketsEl = document.getElementById('overall-markets'),
              teamSpecificResultsEl = document.getElementById('team-specific-results'), calculateRatingsBtn = document.getElementById('calculateRatingsBtn'),
              outrightOddsDataEl = document.getElementById('outrightOddsData'),
              ratingScalingFactorEl = document.getElementById('ratingScalingFactor'),
              progressBarContainer = document.querySelector('.progress-bar-container'),
              progressBar = document.querySelector('.progress-bar'),
              h2hTeamAEl = document.getElementById('h2h-team-a'),
              h2hTeamBEl = document.getElementById('h2h-team-b'),
              calculateH2HBtn = document.getElementById('calculateH2HBtn'),
              h2hResultsEl = document.getElementById('h2h-results');

        let lastResults = null, lastTeams = [];

        // --- Defaults & Initialization ---
        const sampleTeamData = `Serbia,A,75.1\nLatvia,A,37.9\nCzechia,A,14.2\nTurkiye,A,38.8\nEstonia,A,-5.7\nPortugal,A,-16.4\nGermany,B,63.6\nLithuania,B,38.8\nMontenegro,B,14.2\nFinland,B,20.0\nGreat Britain,B,-8.5\nSweden,B,2.1\nSpain,C,42.8\nGreece,C,49.6\nItaly,C,36.3\nGeorgia,C,9.9\nBosnia and Herzegovina,C,16.8\nCyprus,C,-16.4\nFrance,D,59.8\nSlovenia,D,45.9\nPoland,D,9.9\nIsrael,D,6.2\nBelgium,D,5.4\nIceland,D,-16.4`;
        teamDataEl.value = sampleTeamData;
        const defaultBracket = `A1vB4;C1vD4;B2vA3;D2vC3;A2vB3;C2vD3;B1vA4;D1vC4 | W1vW2;W3vW4;W5vW6;W7vW8 | W1vW2;W3vW4 | W1vW2`;
        knockoutStructureEl.value = defaultBracket.replace(/ \| /g, ' |\n');
        
        teamDataEl.addEventListener('input', updateDropdowns);
        runButtonEl.addEventListener('click', runMonteCarlo);
        displayModeToggle.addEventListener('change', () => displayResults(lastResults));
        teamSelectEl.addEventListener('change', () => displayResults(lastResults));
        calculateRatingsBtn.addEventListener('click', calculateRatingsFromOdds);
        calculateH2HBtn.addEventListener('click', displayH2HResults);

        document.querySelectorAll(".collapsible").forEach(coll => {
            coll.addEventListener("click", function() {
                this.classList.toggle("active");
                var content = this.nextElementSibling;
                content.style.maxHeight = content.style.maxHeight ? null : content.scrollHeight + "px";
            });
        });
        
        updateDropdowns();

        function calculateRatingsFromOdds() {
            const lines = outrightOddsDataEl.value.trim().split('\n');
            const teamsWithOdds = lines.map(line => {
                const [name, group, oddsStr] = line.split(',').map(s => s.trim());
                const odds = parseFloat(oddsStr);
                if (name && group && !isNaN(odds) && odds > 0) return { name, group, odds, impliedProb: 1 / odds };
                return null;
            }).filter(Boolean);

            if (teamsWithOdds.length === 0) { alert('No valid odds data. Format: team,group,odds'); return; }
            const totalImpliedProb = teamsWithOdds.reduce((sum, team) => sum + team.impliedProb, 0);
            const teamsWithRatings = teamsWithOdds.map(team => {
                const trueProb = team.impliedProb / totalImpliedProb;
                const rating = 100 + Math.log(trueProb) * 20;
                return { name: team.name, group: team.group, rating: rating.toFixed(1) };
            });

            teamDataEl.value = teamsWithRatings.map(t => `${t.name},${t.group},${t.rating}`).join('\n');
            updateDropdowns();
            alert(`Ratings calculated for ${teamsWithRatings.length} teams!`);
        }
        
        function updateDropdowns() {
            lastTeams = parseTeamData();
            const sortedTeams = [...lastTeams].sort((a, b) => a.name.localeCompare(b.name));
            hostTeamEl.innerHTML = '<option value="none">None</option>';
            teamSelectEl.innerHTML = '<option value="">-- Select a Team --</option>';
            h2hTeamAEl.innerHTML = '';
            h2hTeamBEl.innerHTML = '';
            sortedTeams.forEach(team => {
                const option = `<option value="${team.name}">${team.name}</option>`;
                hostTeamEl.innerHTML += option;
                teamSelectEl.innerHTML += option;
                h2hTeamAEl.innerHTML += option;
                h2hTeamBEl.innerHTML += option;
            });
            if (sortedTeams.length > 1) {
                h2hTeamBEl.value = sortedTeams[1].name;
            }
        }

        function parseTeamData() {
            return teamDataEl.value.trim().split('\n').map(line => {
                const [name, group, rating] = line.split(',').map(s => s.trim());
                if (name && group && !isNaN(parseFloat(rating))) return { name, group, rating: parseFloat(rating) };
                return null;
            }).filter(Boolean);
        }
        
        function calculateWinProbability(teamA, teamB, hostTeam, scalingFactor) {
            const ratingA = teamA.rating + (teamA.name === hostTeam ? HOME_ADVANTAGE_RATING_BONUS : 0);
            const ratingB = teamB.rating + (teamB.name === hostTeam ? HOME_ADVANTAGE_RATING_BONUS : 0);
            return 1 / (1 + Math.pow(10, (ratingB - ratingA) / scalingFactor));
        }

        function simulateMatch(teamA, teamB, hostTeam, scalingFactor) {
            const probA = calculateWinProbability(teamA, teamB, hostTeam, scalingFactor);
            return Math.random() < probA ? {winner: teamA, loser: teamB} : {winner: teamB, loser: teamA};
        }

        async function runMonteCarlo() {
            runButtonEl.disabled = true; statusEl.textContent = 'Preparing...';
            overallMarketsEl.innerHTML = ''; teamSpecificResultsEl.innerHTML = '';

            const teams = parseTeamData();
            if (teams.length < 2) { statusEl.textContent = 'Error: Not enough teams.'; runButtonEl.disabled = false; return; }
            lastTeams = teams;
            
            const numSimulations = parseInt(numSimulationsEl.value);
            const groupFormat = document.querySelector('input[name="groupFormat"]:checked').value;
            const hostTeam = hostTeamEl.value;
            const bracketString = knockoutStructureEl.value;
            const ratingScalingFactor = parseFloat(ratingScalingFactorEl.value) || 30;

            const results = { teams: {}, groups: {}, finalMatchups: {}, groupForecasts: {}, groupOfWinner: {}, matchups: {}, simulationHistory: [] };
            teams.forEach(team => {
                results.teams[team.name] = {
                    group: team.group, rating: team.rating, totalGroupWins: 0, groupPlacements: [], top2Finish: 0, top4Finish: 0,
                    reachesQF: 0, reachesSF: 0, reachesFinal: 0, tourneyWins: 0, runnerUp: 0,
                    eliminatedInGroup: 0, eliminatedInR16: 0, eliminatedInQF: 0, eliminatedInSF: 0,
                    r16_opponents: {}, qf_opponents: {}, sf_opponents: {}, final_opponents: {},
                    groupWinsCount: {},
                    top3Finish: 0,
                    undefeatedWins: 0,
                    metOpponent: {},
                    eliminationStage: 0 // 0: Group, 1: R16, 2: QF, 3: SF, 4: Final, 5: Winner
                };
            });
            for (const team of teams) {
                const groupName = team.group;
                if(!results.groups[groupName]) { results.groups[groupName] = { teams: [], numTeams: 0 }; results.groupForecasts[groupName] = {}; }
                results.groups[groupName].teams.push(team.name);
            }
            for(const groupName in results.groups) {
                const numTeams = results.groups[groupName].teams.length;
                results.groups[groupName].numTeams = numTeams;
                results.groups[groupName].teams.forEach(teamName => { results.teams[teamName].groupPlacements = Array(numTeams).fill(0); });
            }

            statusEl.textContent = `Running 0/${numSimulations}...`;
            progressBarContainer.style.display = 'block';
            progressBar.style.width = '0%';
            
            try {
                for (let i = 0; i < numSimulations; i++) {
                    // Group Stage
                    const groupStandings = {};
                    for (const groupName in results.groups) {
                        const groupTeams = teams.filter(t => t.group === groupName).map(t => ({...t, wins: 0}));
                        for (let j = 0; j < groupTeams.length; j++) for (let k = j + 1; k < groupTeams.length; k++) {
                            const { winner } = simulateMatch(groupTeams[j], groupTeams[k], hostTeam, ratingScalingFactor);
                            groupTeams.find(t => t.name === winner.name).wins++;
                        }
                        groupTeams.sort((a, b) => b.wins - a.wins || Math.random() - 0.5);
                        groupStandings[groupName] = groupTeams;
                        if(groupTeams.length >= 2) {
                            const forecastKey = `${groupTeams[0].name}>${groupTeams[1].name}`;
                            results.groupForecasts[groupName][forecastKey] = (results.groupForecasts[groupName][forecastKey] || 0) + 1;
                        }
                    }

                    for (const groupName in groupStandings) {
                        groupStandings[groupName].forEach((team, index) => {
                            const res = results.teams[team.name];
                            res.groupPlacements[index]++;
                            res.totalGroupWins += team.wins;
                            res.groupWinsCount[team.wins] = (res.groupWinsCount[team.wins] || 0) + 1;
                            if (index < 2) res.top2Finish++;
                            if (index < 4) {
                                res.top4Finish++;
                            } else {
                                res.eliminatedInGroup++;
                                res.eliminationStage = 0;
                            }
                        });
                    }
                    
                    // Knockout Stage
                    const qualifiers = {};
                    for(const groupName in groupStandings) groupStandings[groupName].forEach((team, index) => { if(index < 4) qualifiers[`${groupName}${index+1}`] = team; });
                    
                    const rounds = bracketString.replace(/\n/g, '').split('|');
                    let previousRoundWinners = [], finalLoser = null;
                    
                    function resolveTeam(id) {
                        const normalizedId = id.trim().toUpperCase();
                        if (normalizedId.startsWith('W')) { return previousRoundWinners[parseInt(normalizedId.substring(1), 10) - 1] || null; }
                        return qualifiers[normalizedId] || null;
                    }
                    
                    for (let roundNum = 0; roundNum < rounds.length; roundNum++) {
                        const round = rounds[roundNum], matches = round.split(';').filter(m => m.trim());
                        if (matches.length === 0) continue;
                        const currentRoundWinners = [], currentRoundLosers = [];
                        
                        matches.flatMap(match => match.split('v')).forEach(id => {
                            const team = resolveTeam(id.trim());
                            if(team) {
                                const res = results.teams[team.name];
                                if(roundNum === 1) res.reachesQF++; else if(roundNum === 2) res.reachesSF++; else if(roundNum === 3) res.reachesFinal++;
                            }
                        });

                        for (const match of matches) {
                            const [idA, idB] = match.split('v');
                            const teamA = resolveTeam(idA), teamB = resolveTeam(idB);
                            if (!teamA || !teamB) throw new Error(`Team not found: "${match.trim()}"`);

                            const opponentMapKeys = ['r16_opponents', 'qf_opponents', 'sf_opponents', 'final_opponents'];
                            const key = opponentMapKeys[roundNum];
                           if (key) {
                               results.teams[teamA.name][key][teamB.name] = (results.teams[teamA.name][key][teamB.name] || 0) + 1;
                               results.teams[teamB.name][key][teamA.name] = (results.teams[teamB.name][key][teamA.name] || 0) + 1;
                           }
                           results.teams[teamA.name].metOpponent[teamB.name] = (results.teams[teamA.name].metOpponent[teamB.name] || 0) + 1;
                           results.teams[teamB.name].metOpponent[teamA.name] = (results.teams[teamB.name].metOpponent[teamA.name] || 0) + 1;
                            
                            const {winner, loser} = simulateMatch(teamA, teamB, hostTeam, ratingScalingFactor);
                            currentRoundWinners.push(winner); currentRoundLosers.push(loser);
                        }
                        
                        currentRoundLosers.forEach(team => {
                            const res = results.teams[team.name];
                            if(roundNum === 0) { res.eliminatedInR16++; res.eliminationStage = 1; }
                            else if(roundNum === 1) { res.eliminatedInQF++; res.eliminationStage = 2; }
                            else if(roundNum === 2) { res.eliminatedInSF++; res.eliminationStage = 3; }
                        });

                        if (roundNum === rounds.length - 2) { // Semi-final round
                            if (currentRoundLosers.length >= 2) {
                                const thirdPlaceMatch = simulateMatch(currentRoundLosers[0], currentRoundLosers[1], hostTeam, ratingScalingFactor);
                                results.teams[thirdPlaceMatch.winner.name].top3Finish++;
                            }
                        }

                        if (roundNum === rounds.length - 1) {
                           finalLoser = currentRoundLosers[0];
                           if(finalLoser) {
                               results.teams[finalLoser.name].runnerUp++;
                               results.teams[finalLoser.name].top3Finish++; // Runner-up is also top 3
                               results.teams[finalLoser.name].eliminationStage = 4;
                           }
                        }
                        previousRoundWinners = currentRoundWinners;
                    }

                    if (previousRoundWinners.length === 1) {
                        const winner = previousRoundWinners[0];
                        results.teams[winner.name].tourneyWins++;
                        results.teams[winner.name].top3Finish++; // Winner is also top 3
                        results.groupOfWinner[winner.group] = (results.groupOfWinner[winner.group] || 0) + 1;

                        const groupGames = results.groups[winner.group].numTeams - 1;
                        const winnerGroupWins = groupStandings[winner.group].find(t => t.name === winner.name).wins;
                        
                        if (winnerGroupWins === groupGames) {
                            results.teams[winner.name].undefeatedWins++;
                        }

                        if(finalLoser) {
                            const matchupKey = [winner.name, finalLoser.name].sort().join(' vs ');
                            results.finalMatchups[matchupKey] = (results.finalMatchups[matchupKey] || 0) + 1;
                        }
                        results.teams[winner.name].eliminationStage = 5;
                    }

                    const runHistory = {};
                    for (const team of teams) {
                        runHistory[team.name] = results.teams[team.name].eliminationStage;
                    }
                    results.simulationHistory.push(runHistory);

                    if ((i + 1) % 100 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 0));
                        statusEl.textContent = `Running ${i + 1}/${numSimulations}...`;
                        progressBar.style.width = `${((i + 1) / numSimulations) * 100}%`;
                    }
                }
                lastResults = results;
                displayResults(lastResults);
                statusEl.textContent = `✅ Simulation Complete (${numSimulations.toLocaleString()} runs)!`;
            } catch (error) { statusEl.textContent = `Error: ${error.message}.`; } finally {
                runButtonEl.disabled = false;
                progressBarContainer.style.display = 'none';
            }
        }
        
        function formatValue(prob, margin) {
            const isOdds = displayModeToggle.checked;
            if (prob <= 0) return isOdds ? '—' : '0.00%';
            if (isOdds) { const impliedProb = prob * (1 + margin / 100); return (1 / impliedProb).toFixed(2); }
            return (prob * 100).toFixed(2) + '%';
        }
        
        function displayResults(results) {
            if (!results) return;
            const activeTab = document.querySelector('.tab-button.active').getAttribute('onclick').match(/'([^']+)'/)[1];
            marginInfoEl.style.visibility = displayModeToggle.checked ? 'visible' : 'hidden';
            if (activeTab === 'overall-markets') { displayOverallResults(results); } 
            else if (activeTab === 'team-view') { displayTeamResults(results); }
        }
        
        function displayOverallResults(results) {
            const numSimulations = parseInt(numSimulationsEl.value), groupMargin = parseFloat(groupMarginEl.value) || 0, tourneyMargin = parseFloat(tourneyMarginEl.value) || 0;
            marginInfoEl.textContent = `(Group: ${groupMargin}%, Tourney: ${tourneyMargin}%)`;
            let html = '<h2>Overall Market Analysis</h2>';
            const allTeamsSorted = Object.keys(results.teams).sort();

            for (const groupName in results.groups) {
                html += `<h3>Group ${groupName}</h3>`;
                const groupData = results.groups[groupName];
                const posHeader = Array.from({ length: groupData.numTeams }, (_, i) => `<th>${i+1}</th>`).join('');
                html += `<table><thead><tr><th>Team (Finish Pos.)</th>${posHeader}</tr></thead><tbody>`;
                groupData.teams.sort().forEach(teamName => {
                    const positionsHtml = results.teams[teamName].groupPlacements.map(count => `<td>${formatValue(count / numSimulations, groupMargin)}</td>`).join('');
                    html += `<tr><td>${teamName}</td>${positionsHtml}</tr>`;
                });
                html += '</tbody></table>';
                html += `<div class="grid-layout grid-cols-2" style="align-items: flex-start;"><div><table><thead><tr><th>Team (Group Markets)</th><th>Avg Wins</th><th>Top 2</th><th>Qualify</th></tr></thead><tbody>`;
                groupData.teams.sort().forEach(teamName => {
                    const teamData = results.teams[teamName];
                    html += `<tr><td>${teamName}</td><td>${(teamData.totalGroupWins / numSimulations).toFixed(2)}</td><td>${formatValue(teamData.top2Finish / numSimulations, groupMargin)}</td><td>${formatValue(teamData.top4Finish / numSimulations, groupMargin)}</td></tr>`;
                });
                html += `</tbody></table></div>`;
                html += `<div><table><thead><tr><th>Group ${groupName} Straight Forecast (1st/2nd)</th><th>Chance</th></tr></thead><tbody>`;
                const forecasts = Object.entries(results.groupForecasts[groupName]).sort(([,a],[,b]) => b-a).slice(0, 5);
                forecasts.forEach(([pair, count]) => { html += `<tr><td>${pair.replace('>', ' > ')}</td><td>${formatValue(count / numSimulations, groupMargin)}</td></tr>`; });
                html += '</tbody></table></div></div>';
            }

            html += `<div class="grid-layout grid-cols-2" style="align-items: flex-start;"><div><h3>Tournament Progression</h3><table><thead><tr><th>Team</th><th>Reach QF</th><th>Reach SF</th><th>Reach Final</th><th>Winner</th></tr></thead><tbody>`;
            allTeamsSorted.forEach(teamName => {
                const d = results.teams[teamName];
                html += `<tr><td>${teamName}</td><td>${formatValue(d.reachesQF/numSimulations, tourneyMargin)}</td><td>${formatValue(d.reachesSF/numSimulations, tourneyMargin)}</td><td>${formatValue(d.reachesFinal/numSimulations, tourneyMargin)}</td><td>${formatValue(d.tourneyWins/numSimulations, tourneyMargin)}</td></tr>`;
            });
            html += '</tbody></table></div>';
            html += `<div><h3>Stage of Elimination</h3><table><thead><tr><th>Team</th><th>Group</th><th>R16</th><th>QF</th><th>SF</th><th>Runner-up</th></tr></thead><tbody>`;
             allTeamsSorted.forEach(teamName => {
                const d = results.teams[teamName];
                html += `<tr><td>${teamName}</td><td>${formatValue(d.eliminatedInGroup/numSimulations, groupMargin)}</td><td>${formatValue(d.eliminatedInR16/numSimulations, tourneyMargin)}</td><td>${formatValue(d.eliminatedInQF/numSimulations, tourneyMargin)}</td><td>${formatValue(d.eliminatedInSF/numSimulations, tourneyMargin)}</td><td>${formatValue(d.runnerUp/numSimulations, tourneyMargin)}</td></tr>`;
            });
            html += '</tbody></table></div></div>';

            html += `<h3>Top 20 Most Likely Final Matchups</h3><table><thead><tr><th>Matchup</th><th>Chance</th></tr></thead><tbody>`;
            const finalMatchups = Object.entries(results.finalMatchups).sort(([, a], [, b]) => b - a).slice(0, 20);
            finalMatchups.forEach(([pair, count]) => { html += `<tr><td>${pair}</td><td>${formatValue(count / numSimulations, tourneyMargin)}</td></tr>`; });
            html += '</tbody></table>';

            html += `<h3>Group of Tournament Winner</h3><table><thead><tr><th>Group</th><th>Chance</th></tr></thead><tbody>`;
            const groupOfWinner = Object.entries(results.groupOfWinner).sort(([, a], [, b]) => b - a);
            groupOfWinner.forEach(([group, count]) => { html += `<tr><td>Group ${group}</td><td>${formatValue(count / numSimulations, tourneyMargin)}</td></tr>`; });
            html += '</tbody></table>';

            overallMarketsEl.innerHTML = html;
        }
        
        function displayTeamResults(results) {
            const selectedTeam = teamSelectEl.value;
            if (!selectedTeam || !results) { teamSpecificResultsEl.innerHTML = '<p>Select a team to see their detailed analysis.</p>'; return; }
            
            const d = results.teams[selectedTeam];
            const numSimulations = parseInt(numSimulationsEl.value), groupMargin = parseFloat(groupMarginEl.value) || 0, tourneyMargin = parseFloat(tourneyMarginEl.value) || 0;
            const hostTeam = hostTeamEl.value;
            const ratingScalingFactor = parseFloat(ratingScalingFactorEl.value) || 30;
            marginInfoEl.textContent = `(Group: ${groupMargin}%, Tourney: ${tourneyMargin}%)`;

            let html = `<h3>Analysis for ${selectedTeam}</h3><div class="grid-layout grid-cols-2" style="align-items: flex-start;"><div><h4>Group Stage Markets</h4><table>`;
            html += `<tr><td>Avg Wins in Group</td><td>${(d.totalGroupWins/numSimulations).toFixed(2)}</td></tr>`;
            html += `<tr><td>Finish in Top 2</td><td>${formatValue(d.top2Finish/numSimulations, groupMargin)}</td></tr>`;
            html += `<tr><td>Qualify from Group (Top 4)</td><td>${formatValue(d.top4Finish/numSimulations, groupMargin)}</td></tr>`;
            html += '</table>';

            const groupTeamCount = lastTeams.filter(t => t.group === d.group).length;
            html += `<h4>Exact Group Wins</h4><table><thead><tr><th>Wins</th><th>Chance</th></tr></thead><tbody>`;
            for (let i = 0; i < groupTeamCount; i++) {
                const count = d.groupWinsCount[i] || 0;
                html += `<tr><td>${i}</td><td>${formatValue(count/numSimulations, groupMargin)}</td></tr>`;
            }
            html += `</tbody></table></div><div><h4>Tournament Markets</h4><table>`;
            html += `<tr><td>Win a Medal (Top 3)</td><td>${formatValue(d.top3Finish/numSimulations, tourneyMargin)}</td></tr>`;
            html += `<tr><td>Reach Quarter-Final</td><td>${formatValue(d.reachesQF/numSimulations, tourneyMargin)}</td></tr>`;
            html += `<tr><td>Reach Semi-Final</td><td>${formatValue(d.reachesSF/numSimulations, tourneyMargin)}</td></tr>`;
            html += `<tr><td>Reach Final</td><td>${formatValue(d.reachesFinal/numSimulations, tourneyMargin)}</td></tr>`;
            html += `<tr><td>Win Tournament</td><td>${formatValue(d.tourneyWins/numSimulations, tourneyMargin)}</td></tr>`;
            html += `<tr><td>Win Undefeated</td><td>${formatValue(d.undefeatedWins/numSimulations, tourneyMargin)}</td></tr>`;
            html += '</table></div><div><h4>Stage of Elimination</h4><table>';
            html += `<tr><td>Eliminated in Group Stage</td><td>${formatValue(d.eliminatedInGroup/numSimulations, tourneyMargin)}</td></tr>`;
            html += `<tr><td>Eliminated in Round of 16</td><td>${formatValue(d.eliminatedInR16/numSimulations, tourneyMargin)}</td></tr>`;
            html += `<tr><td>Eliminated in Quarter-Final</td><td>${formatValue(d.eliminatedInQF/numSimulations, tourneyMargin)}</td></tr>`;
            html += `<tr><td>Eliminated in Semi-Final</td><td>${formatValue(d.eliminatedInSF/numSimulations, tourneyMargin)}</td></tr>`;
            html += `<tr><td>Finish as Runner-up</td><td>${formatValue(d.runnerUp/numSimulations, tourneyMargin)}</td></tr>`;
            html += '</table></div></div>';
            
            const groupName = d.group;
            const groupTeams = lastTeams.filter(t => t.group === groupName);
            html += `<h4>Group ${groupName} - Head-to-Head Matchups</h4><table><thead><tr><th>Matchup</th><th>${selectedTeam} Win</th><th>Opponent Win</th></tr></thead><tbody>`;
            groupTeams.filter(t => t.name !== selectedTeam).forEach(opponent => {
                const probSelectedTeamWins = calculateWinProbability({ ...d, name: selectedTeam }, opponent, hostTeam, ratingScalingFactor);
                html += `<tr><td>vs ${opponent.name}</td><td>${formatValue(probSelectedTeamWins, groupMargin)}</td><td>${formatValue(1-probSelectedTeamWins, groupMargin)}</td></tr>`;
            });
            html += `</tbody></table>`;

            html += `<h4>Most Likely Knockout Opponents</h4><div class="grid-layout grid-cols-2" style="align-items: flex-start;">`;
            const opponentMapKeys = { 'Round of 16': 'r16_opponents', 'Quarter-Final': 'qf_opponents', 'Semi-Final': 'sf_opponents', 'Final': 'final_opponents' };
            for(const [title, key] of Object.entries(opponentMapKeys)) {
                html += `<div><table><thead><tr><th>${title} Opponent</th><th>Chance</th></tr></thead><tbody>`;
                const opponents = Object.entries(d[key]).sort(([,a],[,b])=>b-a).slice(0,3);
                if (opponents.length > 0) {
                    opponents.forEach(([name, count]) => {
                        html += `<tr><td>${name}</td><td>${formatValue(count/numSimulations, tourneyMargin)}</td></tr>`;
                    });
                } else {
                    html += `<tr><td colspan="2">N/A</td></tr>`;
                }
                html += `</tbody></table></div>`;
            }
            html += `</div>`;

            html += `<h4>Tournament Matchup Probability</h4>`;
            html += `<label for="opponent-select">Select Opponent:</label><select id="opponent-select">`;
            const otherTeams = lastTeams.filter(t => t.name !== selectedTeam).sort((a, b) => a.name.localeCompare(b.name));
            otherTeams.forEach(opponent => {
                html += `<option value="${opponent.name}">${opponent.name}</option>`;
            });
            html += `</select><div id="matchup-prob-result" style="margin-top:10px;"></div>`;

            teamSpecificResultsEl.innerHTML = html;

            const opponentSelect = document.getElementById('opponent-select');
            if(opponentSelect) {
                opponentSelect.addEventListener('change', () => {
                    const selectedOpponent = opponentSelect.value;
                    const meetingProb = (d.metOpponent[selectedOpponent] || 0) / numSimulations;
                    document.getElementById('matchup-prob-result').innerHTML = `Chance to meet ${selectedOpponent} at any stage: <b>${formatValue(meetingProb, tourneyMargin)}</b>`;
                });
                opponentSelect.dispatchEvent(new Event('change'));
            }
        }

        function displayH2HResults() {
            if (!lastResults || !lastResults.simulationHistory || lastResults.simulationHistory.length === 0) {
                h2hResultsEl.innerHTML = 'Please run a simulation first.';
                return;
            }
            const teamA = h2hTeamAEl.value;
            const teamB = h2hTeamBEl.value;
            if (!teamA || !teamB || teamA === teamB) {
                h2hResultsEl.innerHTML = 'Please select two different teams.';
                return;
            }

            let teamAWins = 0;
            let teamBWins = 0;
            let ties = 0;

            for (const run of lastResults.simulationHistory) {
                const stageA = run[teamA];
                const stageB = run[teamB];
                if (stageA > stageB) {
                    teamAWins++;
                } else if (stageB > stageA) {
                    teamBWins++;
                } else {
                    ties++;
                }
            }

            const total = teamAWins + teamBWins + ties;
            const probA = teamAWins / total;
            const probB = teamBWins / total;
            const probTie = ties / total;

            let html = `
                <p><b>${teamA} progresses further:</b> ${formatValue(probA, 0)}</p>
                <p><b>${teamB} progresses further:</b> ${formatValue(probB, 0)}</p>
                <p><b>Eliminated at same stage:</b> ${formatValue(probTie, 0)}</p>
            `;
            h2hResultsEl.innerHTML = html;
        }
        
        function openTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            document.getElementById(tabName).classList.add('active');
            event.currentTarget.classList.add('active');
            displayResults(lastResults);
        }
    </script>
</body>
</html>
